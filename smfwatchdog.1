.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "SMFWATCHDOG" "1" "June 2013" "" "SMF Watchdog"
.
.SH "NAME"
\fBsmfwatchdog\fR \- SMF Health Checking Daemon
.
.P
A health checking daemon to be used with SMF services\.
.
.IP "\(bu" 4
\fISynopsis\fR
.
.IP "\(bu" 4
\fIInstallation\fR
.
.IP "\(bu" 4
\fIExample\fR
.
.IP "\(bu" 4
\fIOptions\fR
.
.IP "\(bu" 4
\fIUsage\fR
.
.IP "\(bu" 4
\fINotes\fR
.
.IP "\(bu" 4
\fITodo\fR
.
.IP "\(bu" 4
\fILicense (MIT)\fR
.
.IP "" 0
.
.P
 \fI\fR
.
.SH "Synopsis"
SMF manages services on Illumos \fIhttp://illumos\.org\fR based operating systems\. It ensures that services, which may consist of 0 to many processes, are up and running, and handles any failures they may encounter\.
.
.P
The one thing that SMF is lacking however, is the ability to do service level health checks\. SMF bases your services health on process health, checking things such as processes dying, or exiting abnormally, etc\. However, it may be the case that a process is up, has a pid and \fB/proc\fR structure, but has locked up, or is not behaving how it should\. \fBsmfwatchdog\fR is meant to do health checks (in the form of scripts) on your services, and proactively kill or restart the service under failure conditions\.
.
.P
The health check daemon is meant to run as a separate instance for each service you would like to monitor\. For example, an instance of \fBsmfwatchdog\fR would be running under the \fBnginx\fR service, while a different instance of \fBsmfwatchdog\fR would be running under the \fBapache\fR service\. The watchdog instance would only be responsible for checking the service under which it is running\.
.
.P
You can learn more about SMF by reading smf(5) \fIhttp://illumos\.org/man/5/smf\fR\.
.
.P
 \fI\fR
.
.SH "Installation"
Clone this repo, compile the source code, and install
.
.IP "" 4
.
.nf

git clone git://github\.com/bahamas10/smfwatchdog\.git
cd smfwatchdog
make
[sudo] make install
.
.fi
.
.IP "" 0
.
.P
This will install the \fBsmfwatchdog\fR binary and the \fBsmfwatchdog\.1\fR manpage\.
.
.P
 \fI\fR
.
.SH "Example"
A service that is a single Node\.JS \fIhttp://nodejs\.org\fR process acting as a webserver with the given SMF manifest is running on a machine\.
.
.P
\fBdaves\-service\.xml\fR
.
.IP "" 4
.
.nf

<?xml version="1\.0"?>
<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle\.dtd\.1">
<!\-\-
Manifest automatically generated by smfgen\.
\-\->
<service_bundle type="manifest" name="application\-daves\-service" >
    <service name="application/daves\-service" type="service" version="1" >
        <create_default_instance enabled="true" />
        <dependency name="dep1" grouping="require_all" restart_on="error" type="service" >
            <service_fmri value="svc:/milestone/multi\-user:default" />
        </dependency>
        <method_context>
            <method_environment>
                <envvar name=\'PATH\' value=\'/opt/local/bin:/opt/local/sbin:/bin:/usr/bin:/usr/sbin\'/>
            </method_environment>
        </method_context>
        <exec_method type="method" name="start" exec="node /home/dave/daves\-service/server\.js &amp;" timeout_seconds="10" />
        <exec_method type="method" name="stop" exec=":kill" timeout_seconds="30" />
        <template >
            <common_name >
                <loctext xml:lang="C" >Dave\'s Service</loctext>
            </common_name>
        </template>
    </service>
</service_bundle>
.
.fi
.
.IP "" 0
.
.P
This is a fairly standard manifest, generated with smfgen \fIhttps://github\.com/davepacheco/smfgen\fR\. The server code written in Node looks like this:
.
.P
\fBserver\.js\fR
.
.IP "" 4
.
.nf

var http = require(\'http\');

var host = \'localhost\';
var port = 8000;

http\.createServer(onrequest)\.listen(port, host, listening);

function listening() {
  console\.log(\'server started: http://%s:%d/\', host, port);
}

var i = 0;
function onrequest(req, res) {
  console\.log(\'new request\');
  if (++i < 5) res\.end();
}
.
.fi
.
.IP "" 0
.
.P
This webserver has a bug however, on the 5th request and thereafter, all requests will stall, and the server will lock up\. SMF by itself won\'t be able to detect this problem, as the process is up and has a valid \fB/proc\fR structure\. This is where \fBsmfwatchdog\fR can be used to detect and mitigate this issue\.
.
.P
Modify the \fBexec\fR line in the manifest to look like this:
.
.IP "" 4
.
.nf

< <exec_method type="method" name="start" exec="node /home/dave/daves\-service/server\.js &amp;" timeout_seconds="10" />
\-\-\-
> <exec_method type="method" name="start" exec="smfwatchdog &amp; node /home/dave/daves\-service/server\.js &amp;" timeout_seconds="10" />
.
.fi
.
.IP "" 0
.
.P
This instructs the service to start an instance of \fBsmfwatchdog\fR with the node process\.
.
.P
Now, reimport the manifest, and restart the service\. The watchdog will be running as part of the service, which you can verify with \fBsvcs(1M)\fR
.
.IP "" 4
.
.nf

$ svcs \-p daves\-service
STATE          STIME    FMRI
online         10:51:43 svc:/application/daves\-service:default
               10:51:43    32188 smfwatchdog
               10:51:43    32189 node
.
.fi
.
.IP "" 0
.
.P
The watchdog is running, however it has nothing to do, as it has no checks\. We now have to write a health check for the service, to ensure that the webserver is reachable without timing out\.
.
.P
The daemon has created a unique directory for scripts to be placed in \fB/opt/local/share/smf/smfwatchdog/application\-daves\-service:default\fR, you can find that information by looking at the logs of the service\. \fBsmfwatchdog\fR will log to the default log location as found in \fBsvcs \-L <fmri>\fR\.
.
.IP "" 4
.
.nf

$ grep \'plugins directory:\' "$(svcs \-L daves\-service)" | tail \-1
[smfwatchdog@0\.0\.0] [2013\-06\-12T17:51:43\.081Z] plugins directory: /opt/local/share/smf/smfwatchdog/application\-daves\-service:default
.
.fi
.
.IP "" 0
.
.P
Any scripts in this directory will be executed every 60 seconds, and if any of them return with a non\-zero exit code, the service will be restarted, and optionally an email will be sent out alerting of the failed health check and the action taken (including the output generated by the script that failed)\.
.
.P
Since checks are just scripts, we can use any language that we\'d like, so let\'s keep it simple and use bash\. We\'ll create a basic health check to ensure the service is responsive over HTTP\.
.
.IP "" 4
.
.nf

vim /opt/local/share/smf/smfwatchdog/application\-daves\-service\e:default/check\.sh


#!/usr/bin/env bash
CURLE_OPERATION_TIMEDOUT=28
timeout=20 # seconds

curl \-sSk \-m "$timeout" "http://localhost:8000"
if (( $? == $CURLE_OPERATION_TIMEDOUT )); then
        exit 1
else
        exit 0
fi
.
.fi
.
.IP "" 0
.
.P
And ensure the file is executable with:
.
.IP "" 4
.
.nf

chmod +x /opt/local/share/smf/smfwatchdog/application\-daves\-service\e:default/check\.sh
.
.fi
.
.IP "" 0
.
.P
The watchdog daemon will scan the directory every 60 seconds, executing every script it finds, in \fBreaddir(3C)\fR order, and restart the service if any of the scripts exit with a non\-zero exit code\.
.
.P
If curl returns with code 28, that means it has timedout\. In the above script, curl is set to timeout if 20 seconds have elapsed with no response from the server, and then the script itself will return with exit code 1
.
.P
When \fBsmfwatchdog\fR sees that this health check has failed, it will send itself a \fBSIGABRT\fR signal, which will trigger a core dump, and cause the entire service to be restarted by SMF (under most circumstances), see \fIoptions\fR below for different actions to take upon failure\.
.
.P
We can see this happen in the logfile
.
.IP "" 4
.
.nf

tail "$(svcs \-L daves\-service)"
[ Jun 12 17:51:43 Executing start method ("smfwatchdog & node /home/dave/daves\-service/server\.js &")\. ]
[smfwatchdog@0\.0\.0] [2013\-06\-12T17:51:43\.080Z] SMF_FMRI=svc:/application/daves\-service:default
[smfwatchdog@0\.0\.0] [2013\-06\-12T17:51:43\.081Z] plugins directory: /opt/local/share/smf/smfwatchdog/application\-daves\-service:default
[ Jun 12 17:51:43 Method "start" exited with status 0\. ]
server started: http://localhost:8000/
new request
new request
new request
new request
new request
[smfwatchdog@0\.0\.0] [2013\-06\-12T17:57:03\.612Z] check\.sh failed (exit code 1)
[smfwatchdog@0\.0\.0] [2013\-06\-12T17:57:03\.612Z] raising SIGABRT
[ Jun 12 17:57:03 Stopping because process dumped core\. ]
[ Jun 12 17:57:03 Executing stop method (:kill)\. ]
.
.fi
.
.IP "" 0
.
.P
Note that \fBnew request\fR is printed 5 times, as on the 5th time the server will become unresponsive, and the health check will fail\.
.
.P
Optionally, we can set an email address to alert any failures to by setting the environmental variable \fBSMFWATCHDOG_EMAIL\fR in the manifest\.
.
.IP "" 4
.
.nf

<envvar name=\'SMFWATCHDOG_EMAIL\' value=\'dave@daveeddy\.com\'/>
.
.fi
.
.IP "" 0
.
.P
Now, when a health check fails it\'ll fire an informative email containing the output from the health check script that failed, as well as some system information that looks like:
.
.IP "" 4
.
.nf

To: dave@daveeddy\.com
From: noreply@dave\-01\.local
Subject: [smfwatchdog] daves\-service:default failed health check on dave\-01\.local

daves\-service:default failed health check on dave\-01\.local

FMRI: svc:/application/daves\-service:default
Action: raising SIGABRT
Hostname: dave\-01\.local
Time (UTC): 2013\-06\-12T04:38:13
Command: check\.sh
Program: smfwatchdog@0\.0\.0 (compiled Jun 11 2013 21:32:47)

Command Output
curl: (28) Operation timed out after 20000 milliseconds with 0 bytes received
.
.fi
.
.IP "" 0
.
.P
 \fI\fR
.
.SH "Options"
The following options can be passed in as environmental variables, most likely being added to the SMF manifest\.
.
.IP "\(bu" 4
\fBSMFWATCHDOG_DEBUG\fR: (int) If this is non\-zero, \fBsmfwatchdog\fR will produce debug output to the service\'s log file (\fBsvcs \-L <fmri>\fR)
.
.IP "\(bu" 4
\fBSMFWATCHDOG_SLEEP\fR: (int) The time, in seconds, to sleep between running health check scripts, defaults to 60
.
.IP "\(bu" 4
\fBSMFWATCHDOG_ACTION\fR: (int) The action (see below) to take during a health check failure, defaults to 0 (raise \fBSIGABRT\fR)
.
.IP "\(bu" 4
\fBSMFWATCHDOG_UID\fR: (int) If this is non\-zero, \fBsetuid(2)\fR will be called with this variable before any plugins are run to drop privileges
.
.IP "\(bu" 4
\fBSMFWATCHDOG_GID\fR: (int) If this is non\-zero, \fBsetgid(2)\fR will be called with this variable before any plugins are run to drop privileges
.
.IP "\(bu" 4
\fBSMFWATCHDOG_COMMAND\fR: A command to execute (parsed by a shell) after a failure case but before any action is taken, defaults to nothing
.
.IP "\(bu" 4
\fBSMFWATCHDOG_EMAIL\fR: If set, this variable will be used as an email address to send alerts to when a service has failed a health check
.
.IP "\(bu" 4
\fBSMFWATCHDOG_EMAIL_FROM\fR: This is the address from which the above email will be sent, defaults to \fBnoreply@<hostname>\fR
.
.IP "\(bu" 4
\fBSMFWATCHDOG_MAIL_PROG\fR: The mail program to use to send email on the system, it must accept binary email data over stdin, defaults to \fBmailx \-t\fR
.
.IP "\(bu" 4
\fBSMFWATCHDOG_DISABLED\fR: If set, \fBsmfwatchdog\fR will exit cleanly upon starting
.
.IP "\(bu" 4
\fBSMF_FMRI\fR: This shouldn\'t be manually set, it will be set automatically by SMF, and is used to tell the watchdog which service to monitor
.
.IP "" 0
.
.SS "Actions"
You can set the action to be taken during a health check failure by setting \fBSMFWATCHDOG_ACTION\fR to a valid integer listed below\.
.
.IP "" 4
.
.nf

#define ACT_RAISE_SIGABRT  0   /* kill ourself with SIGABRT */
#define ACT_RESTART_SVC    1   /* restart our own service (requires priv) */
#define ACT_EXIT           2   /* exit with a failure error code */
#define ACT_NOTHING        3   /* do nothing */
.
.fi
.
.IP "" 0
.
.P
The default action is to raise a \fBSIGABRT\fR signal to trigger a core dump\. This will cause SMF to restart the entire service, without \fBsmfwatchdog\fR requiring escalated privileges\.
.
.P
Setting this variable to 1 will cause the command \fBsvcadm restart <fmri>\fR to be triggered after a failed health check\. Note that this will only work if the effective UID of the \fBsmfwatchdog\fR daemon has privileges to carry out that command\.
.
.P
Setting this variable to 2 will cause \fBsmfwatchdog\fR to exit with a failure return code after a failed check\.
.
.P
Setting this variable to 3 will cause \fBsmfwatchdog\fR to not take any action except to log and optionally send an email in the event of a failed health check, making it a good option for testing\.
.
.P
 \fI\fR
.
.SH "Usage"
If you run \fBsmfwatchdog\fR interactively (without \fBSMF_FMRI\fR set) you are greeted with
.
.IP "" 4
.
.nf

$ smfwatchdog
smfwatchdog is not meant to be run interatively
.
.fi
.
.IP "" 0
.
.P
as the daemon would have nothing to check\.
.
.P
If \fBsmfwatchdog\fR is run with any number of arguments, the version string is printed and the process exits cleanly\.
.
.IP "" 4
.
.nf

$ smfwatchdog \-v
smfwatchdog@0\.0\.2 (compiled Jun 13 2013 09:09:46)
.
.fi
.
.IP "" 0
.
.P
The proper way to run \fBsmfwatchdog\fR is to add it to the exec line of an SMF manifest, and let SMF start and stop the daemon\.
.
.P
 \fI\fR
.
.SH "Notes"
The watchdog isn\'t a solution to a problem; it doesn\'t fix bugs\. The health checks are meant to minimize the impact of bugs that exist that currently have not been fixed in a service\.
.
.IP "\(bu" 4
This software hasn\'t been fully tested, and may contain bugs
.
.IP "\(bu" 4
Scripts are executed with \fBpopen(3C)\fR, and as such, have their names parsed by the shell\. Ensure that you don\'t name your scripts \fB$(rm \-rf /)\fR or something
.
.IP "\(bu" 4
Don\'t set \fBSMFWATCHDOG_UID\fR or \fBSMFWATCHDOG_GID\fR if the manifest itself takes care of dropping privileges
.
.IP "" 0
.
.P
 \fI\fR
.
.SH "Todo"
.
.IP "\(bu" 4
\fBsmfwatchdog\fR should kill itself when it is the only process running in a contract
.
.IP "\(bu" 4
\fBpclose\fR raises \fBSIGABRT\fR when executing a broken symlink\.
.
.IP "" 0
.
.P
 \fI\fR
.
.SH "License"
MIT License
